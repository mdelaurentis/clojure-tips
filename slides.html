<!DCTYPE html>
<html>
  <head>
    <title>Clojure Best Practices</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Title

---

# Agenda

1. Vars
3. Records
2. Laziness
4. Concurrency

---

# Vars

---

# Vars

## Global variable

```clojure
(def one 
  "The number one"
  1)

(defn say-hello [person]
  "Say hello to person"
  (println "Hello " person))
```

Both vars.

---

# Vars

## Can be evaluated

```clojure
user=> (def one 1)
#'user/one

user=> one
1
```

```clojure
user=> (defn say-hello [person]
         "Say hello to person."
         (println "Hello " person))
#'user/say-hello
=> say-hello
#<user$say-hello user$say-hello@614951ff>
```

---

# Vars

## Can be quoted

```clojure
user=> #'one
#'user/one
```

```clojure
user=> #'say-hello
#'usr/say-hello
```

Quoting gives you *the var itself*. Not the value it points to.

---

# Vars

## Can be invoked

This:

```clojure

(say-hello "Mark")
```

is the same as this:

```clojure
(#'say-hello "Mark")
```

So you can pass vars around like you pass functions around.

---

# Vars - Metadata

```clojure
(defn cat
  "Dump the file to stdout"
  [filename]
  (print (slurp filename)))
```

```clojure
user=> (prn (meta #'cat))
{:ns #<Namespace com.mdelaurentis.clojure-tips.vars>, 
 :name cat,
 :file "/Users/mdelaurentis/code/clojure-tips/src/com/mdelaurentis/clojure_tips/vars.clj",
 :column 1,
 :line 3,
 :arglists ([filename]),
 :doc "Dump the file to stdout"}
```

```clojure
user=> (meta cat)
nil
```

---

# Vars - Metadata

```clojure
(defn cat
  "Dump the file to stdout"
  [filename]
  (print (slurp filename)))

(defn rm
  "Remove the file"
  [filename]
  (.delete (java.io.File. filename)))

(defn cp
  "Copy file from source to destination"
  [source destination]
  (spit destination (slurp source)))

(doseq [command [#'cat #'rm #'cp]]
  (println (:name (meta command)) "-" (:doc (meta command))))
```

```
cat - Dump the file to stdout
rm - Remove the file
cp - Copy file from source to destination
```
---

# Laziness

---

# Laziness

Why doesn't this print anything?

```clojure
(let [items [1 2 3]]
  (map println items)
  items)
```

Laziness.

---

# Laziness

## What does `map` do?

```
user=> (doc map)
-------------------------
clojure.core/map
([f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls])
  Returns a lazy sequence consisting of the result of applying f to the
  set of first items of each coll, followed by applying f to the set
  of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments.
```

---

# Laziness

## doseq

```clojure
(let [items [1 2 3]]
  (doseq [item items]
    (println item))
  items)
```

---

# Laziness

## What does doseq do?

```
user=> (doc doseq)
-------------------------
clojure.core/doseq
([seq-exprs & body])
Macro
  Repeatedly executes body (presumably for side-effects) with
  bindings and filtering as provided by "for".  Does not retain
  the head of the sequence. Returns nil.
```

---

# Laziness

## What about `doall`?

```
user=> (doc doall)
-------------------------
clojure.core/doall
([coll] [n coll])
  When lazy sequences are produced via functions that have side
  effects, any effects other than those needed to produce the first
  element in the seq do not occur until the seq is consumed. doall can
  be used to force any effects. Walks through the successive nexts of
  the seq, retains the head and returns it, thus causing the entire
  seq to reside in memory at one time.
```

---

# Laziness

## doall

```clojure
(with-open [r (io/reader "file.txt")]
  (doall (line-seq r)))
```

---

# Laziness

```
                       Will you consume the result?

                  Will consume             Will not consume



Need side        (doall (map f coll))
effects           or (loop ...)



Don't need 
side effects
```

---

# Laziness

```
                       Will you consume the result?

                  Will consume             Will not consume



Need side        (doall (map f coll))
effects           or (loop ...)



Don't need       (map f coll)
side effects 
```

---

# Laziness

```
                       Will you consume the result?

                  Will consume             Will not consume



Need side        (doall (map f coll))       (doseq [c coll]
effects           or (loop ...)               (f c))



Don't need       (map f coll)
side effects
```

---

# Laziness

```
                       Will you consume the result?

                  Will consume             Will not consume



Need side        (doall (map f coll))       (doseq [c coll]
effects           or (loop ...)               (f c))



Don't need       (map f coll)               What is 
side effects                                wrong with you?
```

---

# Records

---

# Concurrency

---

# Concurrency

## clojure.core

* future
* ref
* agent 

### clojure.core.async

* channels
* channel operations

### Thread pools

* go
* thread
* future
* agents

---

# future

```clojure
(let [result (future (slurp "file.txt"))]
  ;; ... some time later
  @result) ;; deref to get result
```

* Runs body on another thread
* Deref to get result of body
* Deref will block until body is done

---

# ref

```clojure

(def all-words (ref #{}))

(future (dosync (alter all-words conj "hello")))
(future (dosync (alter all-words conj "there")))
...

(println "I know " (count @all-words))
```

* Mutable storage location
* Can be changed with multiple threads concurrently
  * only inside `dosync` block
  * `dosync` provides transaction isolation
* Get current value with deref operator - @
  * `deref` never blocks


---

# delay

```clojure
(def words
  (delay
    (-> "words.txt" slurp split-lines)))

...

@words ;; file is only slurped once
```

* Runs body exactly once
* ... when it's first deref'ed
* On the thread that derefs it

---

# agent

```clojure
(let [a (agent {:id 1})]
  (send a assoc :first-name "Mike")
  (send a assoc :last-name "DeLaurentis")
  @a)

=> ?

```

* Mutable storage location
* Only changed by one thread at a time
  * To modify, `send` a function and the args to the agent
  * `send` runs (apply f agent args) in another thread)
  * and uses the result as new value of agent
* Get current value with deref
  * deref never blocks

---

# core.async

* channels
* channel operations
* threading

---

# core.async

## Channels

* Basically blocking queues

---

# core.async

## Unbuffered channel

```clojure
(chan)
```

* Can't put unless a consumer is waiting to take. 
* Can't take unless a producer is waiting to put.
* Should be your go-to channel type

---

# core.async

## Buffered channel

```clojure
(chan 10)
```

* Holds up to 10 items
* Put blocks if buffer is full
* Take blocks if buffer is empty

---

# channel

## dropping buffer

```clojure
(chan (dropping-buffer 10))
```
 
* Holds up to 10 items
* Put never blocks
* Drops newest item when full

---

# channels

## sliding buffer

```clojure
(chan (sliding-buffer 10))
```
 
* Holds up to 10 items
* `put` never blocks
* Drops oldest item when full

---

# core.async

## Closing a channel

```clojure
(close! ch)
```

* Immediately releases blocked producers & consumers
* Subsequent puts & takes don't block
* Channels *never* produce nil when open
* ... *always* produce nil when closed


---

# core.async

## timeout 

```clojure
;; Wait a minute...
(go (<! (timeout 60000)))
```

---

# core.async

## Channel Operations

---

# core.async

## Putting an item

```clojure
(go (!> ch item))
```

* Tries to put an item on ch
* Park if there's no room
* Returns nil immediately if `ch` is closed

---

# core.async

## Taking an item

```clojure
(go 
  (let [person (<! ch)]
    (println "Hello " person)))
```

* Take an item from ch
* Park if there's no item ready
* Returns nil immediately if ch is closed

---

# channel operations

## `alt!` - taking

```clojure
(alt!

  ;; If we get a job from work-ch, run it 
  work-ch
  ([job] 
    (run-job job))

  (timeout 60000)
  (log/info "No work after a minute"))
```

* Think of it like `cond`
* Attempts two or more channel operation
* Executes the code block under the first one that succeeds

---

# channel operations

## `alt!` - putting

```clojure
(alt!

  ;; If we get a job from work-ch, run it 
  [work-ch job]
  (log/info "I queued a job")

  (timeout 60000)
  (log/info "Couldn't queue a job after a minute"))
```

---

# channel operations

## `alt!` - `:default`

```clojure
(alt!

  ;; If we get a job from work-ch, run it 
  [work-ch job]
  (log/info "I queued a job")

  :default :couldnt-immediately-queue-job)
```

---

# core.async

## `go`

```clojure
(go 
  (>! queue "Jim")
  (>! queue "Mary"))
```

* Macro
* Examines body for channel operations like `<!`, `>!`, `alt!`
* Executes body on another thread
* When it hits a channel operation:
  * "parks" the go block until it completes
  * Yields the thread to run another go block

---

# core.async

# `go-loop`

```clojure
(go 
  (loop []
    (when-let [job (<! work)]
      ...)))
```

---

# core.async

# `go-loop`

```clojure
(go-loop []
  (when-let [job (<! work)]
    ...)))
```
    
---

# core.async

## `go` returns a channel

```clojure
(go 
  (let [queue (chan)

        producer (go
                   (doseq [person people]
                     (>! queue person)))

        consumer (go-loop []
                   (when-let [name (<! queue)]
                     (println "Hello" name)
                     (recur)))]
    (<! producer)
    (<! consumer)
    (println "Everyone has been greeted")))
```

* Go returns a channel
* ... that is closed when the go block is done
* Wait for your go blocks!

---

# Thread Pools

* go
* thread
* future
* agent

---

# Thread Pools

## go - parking

`<!`, `>!`, and `alt!` tell `go` that it should park until the channel operation is ready.

```clojure
(go 
  (let [queue (chan)

        producer (go
                   (doseq [person people]
                     (>! queue person)))

        consumer (go-loop []
                   (when-let [name (<! queue)]
                     (println "Hello" name)
                     (recur)))]
    (<! producer)
    (<! consumer)
    (println "Everyone has been greeted")))
```

---

# Thread Pools

## go thread pool

```clojure
(defonce the-executor
  (Executors/newFixedThreadPool
   (-> (Runtime/getRuntime)
       (.availableProcessors)
       (* 2)
       (+ 42))
   (conc/counted-thread-factory "async-dispatch-%d" true)))
```

* Fixed number of threads
* 2 * number of processors
* \+ 42

---

# Thread Pools

## IO - dangerous

```clojure
(go-loop []
  (when-let [name (<! queue)]
    (Thread/sleep 60000)
    (println name)
    (recur)))
```

* Go only parks on small set of channel operations.
* Other blocking calls will tie up a thread in the pool.
* Too many go blocks doing IO or sleeping can easily fill up the entire thread pool.

```clojure
(go-loop []
  (when-let [url (<! queue)]
    (let [contents (fetch url)]
      (jdbc/insert! db :cached-pages {:url url, :content content})))
      (recur))))
```

---

# Thread Pools

## thread


```clojure
(go-loop []
  (when-let [url (<! queue)]
    (let [contents (<! (thread (fetch url)))]
      (<! (thread (jdbc/insert! db :cached-pages {:url url, :content content})))
      (recur))))
```

* A macro
* Runs the body on another thread
* Returns a channel that produces the result of the body.
* Unlike go:
  * Reserves a *real thread* for the duration of the body
  * Does not park on `<!` or `>!`.
  * Use `<!!` and `>!!` instead.
  * They block, not park.

---

# Where is my code run?

```
         How to   Blocking?  Who runs it?
         get 
         result?

future   @         yes        Cached

send     @         no         Fixed

send-off @         no         Cached

go       <!        yes        Fixed

thread   <!        yes        Cached
```

---

# Thread pools

## clojure.lang.Agent

### Pooled Executor

* For agent `send` actions
* Fixed, 2 + number of processors
* Not at all appropriate for IO

```java

volatile public static ExecutorService pooledExecutor =
        Executors.newFixedThreadPool(2 + Runtime.getRuntime().availableProcessors(),
                createThreadFactory("clojure-agent-send-pool-%d", sendThreadPoolCounter));
```

---

# Thread pools

## clojure.lang.Agent

### Solo Executor

* For agent `send-off` actions
* And `future`s
* Cached
* Good for IO

```java
volatile public static ExecutorService soloExecutor = Executors.newCachedThreadPool(
        createThreadFactory("clojure-agent-send-off-pool-%d", sendOffThreadPoolCounter));
```

---

# Advice

* Close channels to indicate no more work
* Let close! propagate through the syste
* Wait for go blocks and threads to finish
* Don't do too much IO in `go` blocks
  * Especially if there may be other `go` blocks in the same process
* Use alt!
* Use merge


    </textarea>
    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>

