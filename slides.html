<!DOCTYPE html>
<html>
  <head>
    <title>Clojure Best Practices</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Title

---

# Agenda

1. Vars
3. Records
2. Laziness
4. Concurrency
  1. delay, future, ref, agent, atom
  2. clojure.core.async
---

# Vars

---

# Laziness

What does `map` do?

```clojure
user=> (doc map)
-------------------------
clojure.core/map
([f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls])
  Returns a lazy sequence consisting of the result of applying f to the
  set of first items of each coll, followed by applying f to the set
  of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments.
```

```clojure
user=> (doc doseq)
-------------------------
clojure.core/doseq
([seq-exprs & body])
Macro
  Repeatedly executes body (presumably for side-effects) with
  bindings and filtering as provided by "for".  Does not retain
  the head of the sequence. Returns nil.
```

---

# Laziness


```
            Will you consume the result?

                Will consume          Will not consume


Need side      (doall (map f coll))      (doseq [c coll]
effects        or (loop ...)             (f c))


Don't need     (map f coll)              What is 
side effects                            wrong with you?
```

# Records

---

# Concurrency

---              

* clojure.core
  * ref
  * delay
  * agent 
  * future
* clojure.core.async
  * channels
  * buffers
  * channel operations
  * go 
  * thread
  * advice

---

# ref

```clojure
(def counter (ref 1))

;; In some other threads
(dosync (alter counter inc))

;; later

@counter

=> 1
```

---

# future

```clojure
(let [a (future (do-some-work))]
  ;; ... some time later
  @a)

=> (whatever do-some-work returned)
```

# delay

```clojure
(def words
  (delay
    (-> "words.txt" slurp split-lines)))
```

---

# agent

```clojure
(let [a (agent {:id 1})]
  (send a assoc :first-name "Mike")
  (send a assoc :last-name "DeLaurentis")
  @a)

=> ?

```

* Deref never blocks
* @agent always returns latest stored value
* send takes an agent, function, and args
* On another thread, executes (f agent args)

---

# agent

## send thread pool

From clojure.lang.Agents:

```java
volatile public static ExecutorService pooledExecutor =
        Executors.newFixedThreadPool(2 + Runtime.getRuntime().availableProcessors(),
                createThreadFactory("clojure-agent-send-pool-%d", sendThreadPoolCounter));
```

Don't do IO in shared fixed thread pool!

---

```clojure
(let [a (agent {:url "http://rjmetrics.com"})]
  (send a #(assoc % :content (slurp url))
  (send a assoc :last-name "DeLaurentis")
  @a)



# channel 

## unbuffered


```clojure
(chan)
```

* Can't put unless a consumer is waiting to take. 
* Can't take unless a producer is waiting to put.
* Should be your go-to channel type

---

---

# core.async

### Create a channel

```clojure
(def queue (chan))
```

* Like a blocking queue
* Supports blocking put, take, close

---

# core.async

## Putting an item

```clojure
(go (!> ch item))
```

* Tries to put an item on ch
* Park if there's no room
* Returns nil immediately if `ch` is closed

---

# core.async

## Taking an item

```clojure
(go 
  (let [person (<! ch)]
    (println "Hello " person)))
```

* Take an item from ch
* Park if there's no item ready
* Returns nil immediately if ch is closed

---

# core.async

## Closing a channel

```clojure
(close! ch)
```

* Immediately releases blocked producers & consumers
* Subsequent puts & takes return nil without blocking

---

# core.async

## `go`

```clojure
(go 
  (>! queue "Jim")
  (>! queue "Mary"))
```

* Macro
* Examines body for channel operations like `<!`, `>!`, `alt!`
* Executes body on another thread
* When it hits a channel operation:
  * "parks" the go block until it completes
  * Yields the thread to run another go block

---

# core.async

## So far:

* chan - create a channel
* <! - take an item
* >! - put an item
* close! - close the channel
* go - run block on another thread

---

# core.async

## What's this "other thread"?

```clojure
(defonce the-executor
  (Executors/newFixedThreadPool
   (-> (Runtime/getRuntime)
       (.availableProcessors)
       (* 2)
       (+ 42))
   (conc/counted-thread-factory "async-dispatch-%d" true)))
```

* Fixed number of threads
* 2 * number of processors
* \+ 42

---

# core.async

## So am I limited to 44 go blocks?

No!

A go block yields to another go block when it is parked.

```clojure
(def queue (chan))

(go (>! queue "Bill"))

(go (>! queue "Chris"))

(go-loop []
  (when-let [name (<! queue)]
    (println name)
    (recur)))
```

---

# core.async

## IO

```clojure
(go-loop []
  (when-let [job (<! queue)]
    (Thread/sleep 10000)
    (println name)
    (recur)))

```
(let [workers (for [i (range 100)]
                (

---

# channel

## dropping buffer

```clojure
(chan (dropping-buffer 10))
```
 
* Holds up to 10 items
* `put` never blocks
* Drops newest item when full

---

# channel

## sliding buffer

```clojure
(chan (sliding-buffer 10))
```
 
* Holds up to 10 items
* `put` never blocks
* Drops oldest item when full

---

# channel operations

## `alt!` - taking

```clojure
(alt!

  ;; If we get a job from work-ch, run it 
  work-ch
  ([job] 
    (run-job job))

  (timeout 60000)
  (log/info "No work after a minute"))
```

* Think of it like `cond`
* Attempts two or more channel operation
* Executes the code block under the first one that succeeds

---

# channel operations

## `alt!` - putting

```clojure
(alt!

  ;; If we get a job from work-ch, run it 
  [work-ch job]
  (log/info "I queued a job")

  (timeout 60000)
  (log/info "Couldn't queue a job after a minute"))
```

---

# channel operations

## `alt!` - `:default`

```clojure
(alt!

  ;; If we get a job from work-ch, run it 
  [work-ch job]
  (log/info "I queued a job")

  :default :couldnt-immediately-queue-job)
```

---

# core.async

# `go-loop`

```clojure
(go 
  (loop []
    (when-let [job (<! work)]
      ...)))
```

---

# core.async

# `go-loop`

```clojure
(go-loop []
  (when-let [job (<! work)]
    ...)))
```
# Thread pools

```
(go-loop []
                     (when-let [url (<! queue)]
    (jdbc/insert! url

---

---

```
         How to   Blocking?  Who runs it?
         get 
         result?
delay    @         yes        Whoever first derefs it

future   @         yes        Real thread from unbounded pool

send     @         no         Real thread from bounded pool

send-off @         no         Real thread from unbounded pool

go       <!        yes        Logical thread from bounded pool

thread   <!        yes        Real thread from bounded pool
```

---

# Thread pools

## clojure.lang.Agent

### Pooled Executor

* For agent `send` actions
* Fixed, 2 + number of processors
* Not at all appropriate for IO

```java

volatile public static ExecutorService pooledExecutor =
        Executors.newFixedThreadPool(2 + Runtime.getRuntime().availableProcessors(),
                createThreadFactory("clojure-agent-send-pool-%d", sendThreadPoolCounter));

volatile public static ExecutorService soloExecutor = Executors.newCachedThreadPool(
        createThreadFactory("clojure-agent-send-off-pool-%d", sendOffThreadPoolCounter));
```

---

# Thread pools

## clojure.lang.Agent

### Solo Executor

* For agent `send-off` actions
* And `future`s
* Cached
* Good for IO

```java

volatile public static ExecutorService pooledExecutor =
        Executors.newFixedThreadPool(2 + Runtime.getRuntime().availableProcessors(),
                createThreadFactory("clojure-agent-send-pool-%d", sendThreadPoolCounter));

volatile public static ExecutorService soloExecutor = Executors.newCachedThreadPool(
        createThreadFactory("clojure-agent-send-off-pool-%d", sendOffThreadPoolCounter));
```

---

# Advice

* Close channels to indicate no more work
* Let close! propagate through the syste
* Wait for go blocks and threads to finish
* Don't do too much IO in `go` blocks
  * Especially if there may be other `go` blocks in the same process
* Use alt!
* Use merge


    </textarea>
    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>

pres
