<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Title

---

# Agenda

1. Vars
3. Records
2. Laziness
4. Concurrency
  1. delay, future, ref, agent, atom
  2. clojure.core.async
---

# Vars

# Laziness

What does `map` do?

```clojure
user=> (doc map)
-------------------------
clojure.core/map
([f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls])
  Returns a lazy sequence consisting of the result of applying f to the
  set of first items of each coll, followed by applying f to the set
  of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments.
```

```clojure
user=> (doc doseq)
-------------------------
clojure.core/doseq
([seq-exprs & body])
Macro
  Repeatedly executes body (presumably for side-effects) with
  bindings and filtering as provided by "for".  Does not retain
  the head of the sequence. Returns nil.
```

---

# Laziness


```
            Will you consume the result?

                Will consume          Will not consume


Need side      (doall (map f coll))      (doseq [c coll]
effects        or (loop ...)             (f c))


Don't need     (map f coll)              What is 
side effects                            wrong with you?
```

# Records

---

# Concurrency

---              

* channels
* buffers
* channel operations
* go 
* thread
* advice

---

# channel 

## unbuffered


```clojure
(chan)
```

* Can't put unless a consumer is waiting to take. 
* Can't take unless a producer is waiting to put.
* Should be your go-to channel type

---

# channel

## fixed buffer

```clojure
(chan 10)
```
* Allows producer to get ahead of consumer 

---

# channel

## dropping buffer

```clojure
(chan (dropping-buffer 10))
```
 
* Holds up to 10 items
* `put` never blocks
* Drops newest item when full

---

# channel

## sliding buffer

```clojure
(chan (sliding-buffer 10))
```
 
* Holds up to 10 items
* `put` never blocks
* Drops oldest item when full

---

# channel operations

## `<!`

```clojure
(<! ch)
```

* Take an item from ch
* Park if there's no item ready
* Returns nil immediately if ch is closed

---

# channel operations

## `>!`

```clojure
(!> ch item)
```

* Put an item on ch
* Park if there's no room
* Returns nil immediately if ch is closed

---

# channel operations

## `alt!` - taking

```clojure
(alt!

  ;; If we get a job from work-ch, run it 
  work-ch
  ([job] 
    (run-job job))

  (timeout 60000)
  (log/info "No work after a minute"))
```

---

# channel operations

## `alt!` - putting

```clojure
(alt!

  ;; If we get a job from work-ch, run it 
  [work-ch job]
  (log/info "I queued a job")

  (timeout 60000)
  (log/info "Couldn't queue a job after a minute"))
```

---

# channel operations

## `alt!` - `:default`

```clojure
(alt!

  ;; If we get a job from work-ch, run it 
  [work-ch job]
  (log/info "I queued a job")

  :default :couldnt-immediately-queue-job)
```

# channel operations 

## `close!`

* Anyone can close a channel
* Immediately releases blocked producers & consumers
* Subsequent puts & takes return nil without blocking

---

# `go`

* Macro
* Examines body for channel operations like `<!`, `>!`, `alt!`
* Executes body on a thread pool
* When it hits a channel operation:
  * "parks" the go block until it completes
  * frees up the thread to run another go block

```clojure
(go 
  (loop []
    (when-let [job (<! work)]
      (>! results (do-work job)))))
```


---

# Advice

* Close channels to indicate no more work
* Let close! propagate through the syste
* Wait for go blocks and threads to finish
* Don't do too much IO in `go` blocks
  * Especially if there may be other `go` blocks in the same process
* Use alt!
* Use merge


    </textarea>
    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>

pres
